@startuml

package helloworld {

    interface GreeterService {
        +Hello(ctx, *Request) (*Response, error)
    }

    class GreeterServiceImpl {
        +Hello(ctx, *Request) (*Response, error)
    }
    GreeterServiceImpl -up-|> GreeterService

    class GreeterServiceDesc {
        Name
        Methods map[strin]HandleFunc
    }
}
note top of helloworld
    通常我们由google protobuf作为IDL:
    - 指导服务api的定义
    - 指导client和server stub生成
end note


package server {

    class Server {
        +services []*Service
        +Start()
        +Stop()
        +Handle(h Handler)
    }
    Server -up-> GreeterServiceImpl
    'note top of Handler : type GreeterService struct{} \nfunc (s *GreeterService) Hello(ctx, req) (rsp, error)

    Server -up-> GreeterServiceDesc

    interface Service {
        +Start()
        +Stop()
    }

    Server "1" -down-> "N" Service
    'note bottom of Server
    '    包含多个Service，Service有自己的ServerTransport，
    '    各Service各司其职，互不干扰
    'end note

    class service {
    	svr *Server
    	registry *registry.Register
    	router *router.Router
    	transport transport.ServerTransport
    }
    service -up-|> Service
    service -down-> transport.ServerTransport
    service -down-> registry.Registry
    service -> router.Router

}

package others {
package interceptor {
    interface Interceptor {
    }
}

package filter {
	interface Filter {
	}
}

package Auth {
	interface Auth {
	}
}

package limiter {
	interface Limiter {
	}
}

package breaker {
    interface Breaker {
    }
}
}

package codec {

    interface Session {
        TraceContext() (interface{}, error)
        ParseRequestBody(req interface{}) error
        Request() interface{}
        Response() interface{}
        Logger() logger
    }

    interface Codec {
        Encode(v interface{}) ([]byte, error)
        Decode([]byte) (interface{}, error)
    }

    interface ClientCodec {
    	Codec
    }
    ClientCodec -up-|> Codec

    interface ServerCodec {
		Codec
    }
    ServerCodec -up-|> Codec

    interface MessageReader {
        Read(net.Conn) (interface{}, error)
    }
	class messageReader {
    	+Codec
    	+Read(net.Conn) (interface{}, error)
    }
    messageReader -left-|> MessageReader
    messageReader -down-> Codec
    messageReader -down-> SessionBuilder

    interface SessionBuilder {
    	Build(req interface{}) (Session, error)
    }

    SessionBuilder -down-> Session
}

package registry {
    interface Registry {
        +Register(*Service, opts ... RegisterOption) error
        +DeRegister(*Service) error
        +GetService(string) ([]*Service, error)
        +ListServices() ([]*Service, error)
        +Watcher() (Watcher, error)
    }
    Registry "1" *-down- "1" Watcher

    interface Watcher {
        +Next() (*Result, error)
        +Stop()
    }
    Watcher -right-> Result

    class Result {
        +Action ActionType
        +Service *Service
    }
    enum ActionType {
        CREATE
        UPDATE
        DELETE
    }
    Result -up-> ActionType
}
note top of registry
naming service
end note

package transport {

	interface ServerTransport {
		ListenAndServeStream(opts...Option) error
		ListenAndServePacket(opts...Option) error
		ListenAndServeHTTP(opts...Option) error
	}

    class serverTransport {
    	opts *options
    	codec *codec.Codec
    	reader *codec.MessageReader
    }
    serverTransport -up-|> ServerTransport
    serverTransport -> codec.MessageReader

    interface ClientTransport {
        Send(ctx, req) (rsp, error)
    }

    class clientTransport {
    	opts *options
    	reader *codec.MessageReader
    	codec codec.Codec

     	tcpPool *TcpConnectionPool
        udpPool *UdpSocketPool
        rd *codec.MessageReader
    }
    clientTransport -up-|> ClientTransport
    clientTransport -> codec.MessageReader
    clientTransport -> TcpConnectionPool

    interface ConnectionPool {
        +GetConn() (net.Conn, error)
        +FreeConn(net.Conn)
    }
    TcpConnectionPool --|> ConnectionPool
    UdpSocketPool --|> ConnectionPool

    TcpConnectionPool "1" --> "N" Endpoint
    UdpSocketPool "1" --> "N" Endpoint

    class Endpoint {
        -conn net.Conn
        +Read([]byte) (n, error)
        +Write([]byte) (n, error)
    }

}

package client {

    interface Client {
        Invoke(ctx, req) (rsp, error)
    }

    class client {

        tcpPool *TcpConnectionPool
        udpPool *UdpSocketPool
        rd *codec.MessageReader

        name string
        codec Codec
        selector Selector
        trans Transport
        +Invoke(ctx, req) (rsp, error)
    }
    note left: general client

    client -|> Client
    client -> transport.ClientTransport
    client -> Selector

    package selector {
        interface Selector {
	        Select(service string, opts ...SelectOption) (Next, error)
	        Mark(service string, node *registry.Node, err error)
	        Reset(service string)
	        Close() error
        }

        SimpleSelector -up-|> Selector
        ConsulSelector -up-|> Selector
        EtcdSelector -up-|> Selector
        Selector -up-> Registry
        note bottom of EtcdSelector
            loadbanlancer based on NamingService
        end note

    }
}

package gorpc {
    class Wrapper {
        +NewService(name, addr, version string)
        +Run()
        +NewServiceClient(name, version string)
    }
    Wrapper --> Service

    class Service {
        +Name string
        +Version string
        +Run(svr *Server)
    }
}
note left of Wrapper
    gorpc.NewService注册新服务
    Run运行服务实例
    NewClient创建rpcclient
end note

package broker {
    interface Broker {
        ServerModule
        Subsribe(ctx, topic, gp) (<-chan interface{}, error)
        Publish(ctx, topic, req) error
    }
    Broker -right-|> Service

    class NATS {
        NewBroker(masterAddr) (Broker, error)
    }
    NATS -up-|> Broker

    class Kafka {
        NewBroker(masterAddr) (Broker, error)
    }
    Kafka -up-|> Broker
}
note top of Broker
message bus
end note

package router {
    interface Router {
        Route(rpc string) (Method, error)
    }
}

package tracing {
    interface Tracer {
        Begin(session)
        Finish(session)
    }

    service -right-> Tracer
    client -up-> Tracer
}
note right: tracing definition

@enduml